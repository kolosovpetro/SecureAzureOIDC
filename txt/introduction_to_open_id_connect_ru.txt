====Определение OpenId Connect====

OpenId Connect — это дополнительный уровень идентификации поверх протокола OAuth 2.0.
Он позволяет клиентам проверять личность конечного пользователя на основе аутентификации,
а также получать базовую информацию профиля конечного пользователя.

====Как OIDC связан с OAuth 2.0====

OAuth 2.0 — это протокол, позволяющий стороннему приложению получить ограниченный доступ к HTTP-сервису, либо от имени resource_owner, 
организуя взаимодействие по утверждению между resource_owner и HTTP-сервисом, либо путем разрешения стороннему приложению получить доступ от своего 
имени.

OAuth 2.0 предоставляет различные стандартизированные потоки сообщений, основанные на JSON и HTTP; OpenID Connect использует их для предоставления 
услуг идентификации.

====Какие проблемы решает OAuth 2.0 и в чем преимущества OAuth 2.0 в сравнении с Basic Authorization====

В традиционной модели аутентификации клиент-сервер, клиент запрашивает ресурс с ограниченным доступом
через аутентификацию с использованием пары логин-пароль (Basic).
Для того чтобы предоставить сторонним приложениям доступ к ресурсам, владелец ресурса делится (пользователь)
своими учетными данными, в данном случае парой логин-пароль, со сторонним приложением.
Такой подход создает ряд проблем и ограничений:

1. Сторонние приложения должны хранить учетные данные (логин и пароль) владельца ресурса для дальнейшего использования,
бывает так, что пароль хранится в явном виде в базе данных.

2. Сторонние приложения обязаны поддерживать аутентификацию с помощью пароля, несмотря на недостатки безопасности, присущие паролям.

3. Сторонние приложения получают полный доступ к защищенным ресурсам владельца ресурса (пользователя),
оставляя владельцев ресурсов без какой-либо возможности ограничить продолжительность доступа или подмножество доступных ресурсов (scope).

4. Владельцы ресурсов (пользователи) не могут отозвать доступ к отдельному третьему лицу без отзыва доступа для всех третьих лиц,
и должны отозвать доступ путем изменения пароля.

5. Взлом либо утечка данных из любого стороннего приложения приводит к потере пароля конечного пользователя и всех данных,
защищенных этим паролем.

OAuth 2.0 решает эти проблемы путем введения уровня авторизации и разделения
роли клиента (сервис авторизации) и владельца ресурса (пользователя).
В OAuth 2.0 клиент запрашивает доступ к ресурсам, контролируемым владельцем ресурса и размещенным на сервере ресурса.
Вместо того чтобы использовать учетные данные владельца ресурса для доступа к защищенным ресурсам, клиент получает токен доступа.

====Explain the diagram OAuthPkceScheme_1570_1055====

1. После нажатия на кнопку "Sign in with Google" происходит перенаправление на ендпоинт авторизации, на котором владелец ресурса должен ввести
свои учетные данные, а так же согласиться с некоторыми условиями.
Особое внимание стоит обратить на code_challenge и code_challenge_method, первое представляет собой некоторую строку,
которая будет закодирована с помощью метода кодировки указанного в параметре запроса code_challenge_method.
В дальнейшем, при обмене полученного кода на токен доступа и обновления, мы должны будем предъявить значение code_verifier,
которое равно ранее закондированному code_challenge.

2. После успешной аутентификации, произойдет перенаправление на адресс redirect_uri.
Что касается параметров запроса code и state:

Code - это код авторизации, который получается с помощью сервера авторизации и является посредником между клиентов и владельцев ресурса.
Перед тем как сервер авторизации перенаправит владельца ресурса обратно на клиент, сервер авторизации проверяет подлиность владельца ресурса.
Так образом поскольку владелец ресурса аутентифицируется только на сервере авторизации, его учетные данные никогда не передадутся клиенту.

State - значение, используемое клиентом для сохранения состояния между запросом на авторизацию и обратным вызовом (callback). 
Сервер авторизации включает это значение при перенаправлении агента пользователя обратно клиенту. Параметр ДОЛЖЕН использоваться для предотвращения 
Cross-Site Request Forgery (CSRF) атак.

3. После получения авторизационного кода обмениваем его на токены доступа и обновления. Если ранее, при переадресации владельца ресурса на
авторизационный ендпоинт, мы указывали code_challenge и code_challenge_method, то мы обязаны ввести значение code_verifier.

====Что такое Proof of Key Code Exchange (PKCE) и какие уязвимости он устраняет====

Authorization code flow with PKCE представляет секрет, созданный клиентом, который может быть проверен сервером авторизации, этот секрет 
называется code_verifier. Клиент создает значение преобразования code_verifier под названием code_challenge и отправляет это значение по HTTPS 
для получения кода авторизации. При обмене кода авторизации на токены, обязательно нужно указать code_verifier.

PKCE решает проблему безопасного обмена кода. Если злоумышленнику удастся заполучить авторизационный код, то у него не получится обменять
его на токены доступа и обновления.