====Определение OpenId Connect====

OpenId Connect — это дополнительный уровень идентификации поверх протокола OAuth 2.0.
Он позволяет клиентам проверять личность конечного пользователя на основе аутентификации,
а также получать базовую информацию профиля конечного пользователя.

====Как OIDC связан с OAuth 2.0====

OAuth 2.0 — это протокол, позволяющий стороннему приложению получить ограниченный доступ к HTTP-сервису, либо от имени владельца ресурса,
организуя взаимодействие по утверждению между владельцем ресурса и HTTP-сервисом, либо путем разрешения стороннему приложению получить
доступ от своего имени.

OAuth 2.0 предоставляет различные стандартизированные потоки сообщений, основанные на JSON и HTTP; OpenID Connect использует их для предоставления 
услуг идентификации.

====Какие проблемы решает OAuth 2.0 и в чем преимущества OAuth 2.0 в сравнении с Basic Authorization====

В базовой (Basic) модели аутентификации клиент-сервер, клиент запрашивает ресурс с ограниченным доступом
через аутентификацию с использованием пары логин-пароль.
Для того чтобы предоставить сторонним приложениям доступ к ресурсам,
владелец ресурса (пользователь) делится своими учетными данными (логином и паролем) со сторонним приложением.
Этот подход создает ряд проблем и ограничений:

1. Сторонние приложения должны хранить учетные данные (логин и пароль) владельца ресурса для дальнейшего использования,
бывает так, что пароль хранится в явном виде в базе данных.

2. Сторонние приложения обязаны поддерживать аутентификацию с помощью пароля, несмотря на недостатки безопасности, присущие паролям.

3. Сторонние приложения получают полный доступ к защищенным ресурсам владельца ресурса (пользователя),
оставляя владельцев ресурсов без какой-либо возможности ограничить продолжительность доступа или подмножество доступных ресурсов (scope).

4. Владельцы ресурсов (пользователи) не могут отозвать доступ к отдельному третьему лицу без отзыва доступа для всех третьих лиц,
и должны отозвать доступ только путем изменения пароля.

5. Взлом либо утечка данных из любого стороннего приложения приводит к потере пароля конечного пользователя и всех данных,
защищенных этим паролем.

OAuth 2.0 решает эти проблемы путем введения уровня авторизации и разделения
роли клиента (сервис авторизации) и владельца ресурса (пользователя).
В OAuth 2.0 клиент запрашивает доступ к ресурсам, контролируемым владельцем ресурса и размещенным на сервере ресурса.
Вместо того чтобы использовать учетные данные владельца ресурса для доступа к защищенным ресурсам, клиент получает токен доступа.

====Объяснение диаграммы OAuthPkceScheme_1570_1055====

1. После нажатия на кнопку "Sign in with Google" происходит перенаправление на ендпоинт авторизации,
на котором владелец ресурса должен ввести свои учетные данные, а так же согласиться с некоторыми условиями.
Особое внимание стоит обратить на code_challenge и code_challenge_method, первое представляет собой некоторую строку,
которая будет закодирована с помощью метода кодировки указанного в параметре запроса code_challenge_method.
В дальнейшем, при обмене полученного кода на токен доступа и обновления, мы должны будем предъявить значение code_verifier,
которое равно ранее закондированному code_challenge.

2. После успешной аутентификации, произойдет перенаправление на адресс redirect_uri.
Что касается параметров запроса code и state:

Code - это код авторизации, который получается с помощью сервера авторизации и является посредником между клиентов и владельцев ресурса.
Перед тем как сервер авторизации перенаправит владельца ресурса обратно на клиент, сервер авторизации проверяет подлинность владельца ресурса.
Так образом поскольку владелец ресурса аутентифицируется только на сервере авторизации, его учетные данные никогда не передадутся клиенту.

State - значение, используемое клиентом для сохранения состояния между запросом на авторизацию и обратным вызовом (callback). 
Сервер авторизации включает это значение при перенаправлении агента пользователя обратно клиенту.
Этот параметр используется для предотвращения Cross-Site Request Forgery (CSRF) атак.

3. После получения авторизационного кода происходит обмен этого кода на токены доступа (access token) и обновления (refresh token).
Если ранее, при переадресации владельца ресурса на авторизационный ендпоинт, мы указывали code_challenge и code_challenge_method,
то теперь, при обмене кода на токены, мы обязаны передать в запросе значение code_verifier.

====Что такое Proof of Key Code Exchange (PKCE) и какие уязвимости он устраняет====

Authorization code flow with PKCE является протоколом, который представляет секрет, созданный клиентом,
который может быть проверен сервером авторизации.
Этот секрет называется code_verifier. Клиент хеширует значение code_verifier и записывает его в параметр code_challenge.
PKCE решает проблему безопасного обмена кода. Если злоумышленнику удастся заполучить авторизационный код, то у него не получится обменять
его на токены доступа и обновления.
Таким образом, мы гарантируем тот факт, что обмен кода на токены производит то же самое приложение, что и выполняло аутентификацию.
В некотором роде, PKCE можно сравнить с цифровой подписью процесса аутентификации.
При обмене кода авторизации на токены обязательно нужно указать code_verifier.