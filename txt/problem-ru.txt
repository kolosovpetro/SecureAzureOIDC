Проблема: Безопасное хранение и передача токенов доступа между микросервисами.

Разделяют два способа хранения токена доступа, а именно хранение в Local Storage и хранение в Cookie.

Local storage - это механизм веб-браузера, который позволяет веб-приложениям хранить данные локально
на устройстве пользователя.
Важно заметить, что Local storage уязвим для атак вида Cross Site Scripting (XSS).
Cross Site Scripting (XSS) - это тип атаки, суть которого в том чтобы внедрить вредоносный JavaScript код
в выдаваемую html-страницу с целью похищения данных пользователя, например токенов доступа.
Различают несколько видов XSS атак:
1. Отражённый XSS (Reflected XSS) - это тип атаки, при которой вредоносный
скрипт передается веб-серверу через параметры URL или формы, а затем возвращается обратно в html-код страницы
без должной фильтрации или экранирования. Когда пользователь открывает такую страницу, скрипт выполняется
в его браузере, что может привести к краже данных.
2. Хранимая XSS (Stored XSS) - это тип атаки, при которой вредоносный скрипт сохраняется на сервере, например
в базе данных, и отображается на веб-страницах. Скрипт выполняется в браузерах других пользователей,
запрашивающие эти страницы.
3. XSS (Cross-Site Scripting) в DOM-модели - это тип атаки на безопасность, где вредоносный скрипт
модифицирует DOM-дерево веб-страницы, выполняясь в браузере пользователя. Часто завязан на модификации
URL-строки.

В свою очередь, Cookie - небольшой фрагмент данных, отправленный веб-сервером и хранимый на устройстве пользователя.
Хранение токенов доступа в Cookie невелирует потенциальные XSS атаки, так как достаточно установить флаг HttpOnly,
запрещающий JS-коду чтение данных из Cookie.
Передача токенов доступа в запросах осуществляется с использованием JavaScript Http методов с флагом { withCredentials: true },
таким образом, если куки существует, то оно передается вместе с запросом, но все еще не может быть прочитано используя
JavaScript.
Пример такого запроса следующий
return this.httpClient.post<TokensResponse>(this.baseUrl + this.sessionsRoute, command, {
      withCredentials: true
});

Однако, файлы куки уязвимы для Cross-Site Request Forgery (CSRF) атак.
Cross-Site Request Forgery (CSRF) - представляет собой атаку, в которой злоумышленник создает запрос на своем
веб-сайте, который отправляется от имени авторизованного пользователя на веб-сайт, где пользователь имеет
активную сессию. Таким образом, запрос может содержать файлы куки что дает возможность прочитать их на стороннем ресурсе злоумышленника.

Файлы куки имеют параметр SameSite, который контроллирует отправку куки для запросов сделанных с других сайтов.
Существует 3 состояния параметра SameSite:
1. None - прямо указывает что на передачу cookie-файлов не накладывается никаких ограничений.
2. Lax - разрешает передачу cookie только безопасными HTTP-методами, которыми, согласно RFC 7231 (ссылка на литературу тут),
являются GET, HEAD, OPTIONS и TRACE.
3. Strict - является самым строгим вариантом безопасности и блокирует отправку cookie с любыми запросами от других
ресурсов. Файлы куки будут передаваться только в пределах того домена, с которого они и были установлены.

Таким образом, состояния параметра Lax и Strict защищают пользователя от CSRF-атаки.